# *Cryptography.2*
Перейдя по ссылке в таске видим приложение на *Flask*, обрабатывающее запросы к разделу */guess_bit*. При получении GET запроса приложение обрабатывает аргумент bit. Попробуем перейти по ***"10.10.18.10:1177/guess_bit?bit=0"***
Видим **большое** число. Само приложение при получении bit обрабатывает его, находя бит в флаге с индексом bit. После чего, если этот бит флага равен 1 то выдаёт 
> 7 ** getPrime(300) % n. 

Если же нет, то выводит случайное число от n//2 до n.
Попробуем сделать программу которая отличает *7 ** getPrime(300) % n (далее "pow")* от случайного числа в диапозоне от n // 2 до n.
Переведя ***"nto{}"*** в биты можно заметить что первый бит = 1. А значит при обращении с аргументом bit = 0, мы должны получать *pow*.
Пообновляв страницу несколько раз, замечаем, что pow зачастую меньше чем n // 2.
Напишем код, который к каждому индексу будет отправлять запрос несколько раз, и если хотя бы раз мы получим число меньшее n // 2, то на этом месте в флаге стоит 1, иначе 0.
Поперебирав значения bit, узнаём, что флаг длинной 135 бит(от 0 до 134).
Код пробует 10 раз сделать запрос с каждым значением *bit* от 0 до 134, из наших наблюдений с большой долей вероятности мы узнаем, если на этом месте стоит 1. 
Если флаг вывелся не полностью или некоректно, запустим код заново.
![](https://raw.githubusercontent.com/Jacute/NTO-user18/main/Crypto2/screenshot.png)
***Получим :'nto{0h_n0_t1m1ng}'***
